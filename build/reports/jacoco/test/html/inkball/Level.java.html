<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Level.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">inkball_scaffold</a> &gt; <a href="index.source.html" class="el_package">inkball</a> &gt; <span class="el_source">Level.java</span></div><h1>Level.java</h1><pre class="source lang-java linenums">package inkball;

import java.util.*;
import java.util.concurrent.CopyOnWriteArrayList;
import processing.data.JSONArray;
import processing.data.JSONObject;
import processing.core.PImage;

/**
 * The Level class manages the entities and layout of a specific game level.
 * It loads the level layout from a configuration file and creates game entities such as walls, spawners,
 * holes, and balls. Additionally, it handles the updating and drawing of these entities, as well as
 * managing game logic such as score and timing.
 */
public class Level {
<span class="fc" id="L16">    int[] scoreIncreaseArray = new int[5]; // Score increase values for each ball color</span>
<span class="fc" id="L17">    int[] scoreDecreaseArray = new int[5]; // Score decrease values for each ball color</span>
    private List&lt;Ball&gt; balls;
    private List&lt;Wall&gt; walls;
    private List&lt;Spawner&gt; spawners;
    private List&lt;Hole&gt; holes;
    List&lt;AccelerateTile&gt; accelerationTiles;  // List of all acceleration tiles
    private ConfigReader configReader;

<span class="fc" id="L25">    boolean isLevelEnded = false;  // Whether the level has ended</span>
<span class="fc" id="L26">    int timeBonusRemaining = 0;        // Remaining time for bonus phase in seconds</span>
    private PImage defaultTileImage;        // Image for default tiles
    YellowTile yellowTileTopLeft;    // Top-left yellow tile
    YellowTile yellowTileBottomRight; // Bottom-right yellow tile

    /**
     * Constructs a Level object and initializes the entity lists and score modification arrays.
     *
     * @param p               The App instance used to load images.
     */
<span class="fc" id="L36">    public Level(int levelIndex, ConfigReader configReader, App p) {</span>

<span class="fc" id="L38">        balls = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L39">        walls = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L40">        spawners = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L41">        holes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L42">        accelerationTiles = new ArrayList&lt;&gt;();</span>

        // Load images directly in Level class
<span class="fc" id="L45">        defaultTileImage = p.loadImage(&quot;inkball/tile.png&quot;);</span>

        // Retrieve score modifiers from the ConfigReader
<span class="fc" id="L48">        double scoreIncreaseModifier = configReader.getScoreIncreaseModifier(levelIndex);</span>
<span class="fc" id="L49">        double scoreDecreaseModifier = configReader.getScoreDecreaseModifier(levelIndex);</span>

        // Populate the score arrays for each color using ConfigReader
<span class="fc bfc" id="L52" title="All 2 branches covered.">        for (int i = 0; i &lt; 5; i++) {</span>
<span class="fc" id="L53">            String color = ColorUtils.numberToColor(i);</span>
<span class="fc" id="L54">            int baseIncreaseValue = configReader.getScoreIncrease(color);</span>
<span class="fc" id="L55">            int baseDecreaseValue = configReader.getScoreDecrease(color);</span>

            // Apply score modifiers to base values
<span class="fc" id="L58">            scoreIncreaseArray[i] = (int) (baseIncreaseValue * scoreIncreaseModifier);</span>
<span class="fc" id="L59">            scoreDecreaseArray[i] = (int) (baseDecreaseValue * scoreDecreaseModifier);</span>
        }
<span class="fc" id="L61">    }</span>

    /**
     * Increases the player's score based on the captured ball's color.
     *
     * @param colorIndex The index of the ball's color.
     * @param app        The main game application to update the score.
     */
    public void increaseScore(int colorIndex, App app) {
<span class="fc bfc" id="L70" title="All 4 branches covered.">        if (colorIndex &gt;= 0 &amp;&amp; colorIndex &lt; scoreIncreaseArray.length) {</span>
<span class="fc" id="L71">            int amount = scoreIncreaseArray[colorIndex];</span>
//            System.out.println(&quot;Increasing score by: &quot; + amount);
<span class="fc" id="L73">            app.increaseScore(amount);</span>
        }
<span class="fc" id="L75">    }</span>

    /**
     * Decreases the player's score based on the wrong hole capture for a specific ball color.
     *
     * @param colorIndex The index of the ball's color.
     * @param app        The main game application to update the score.
     */
    public void decreaseScore(int colorIndex, App app) {
<span class="pc bpc" id="L84" title="1 of 4 branches missed.">        if (colorIndex &gt;= 0 &amp;&amp; colorIndex &lt; scoreDecreaseArray.length) {</span>
<span class="fc" id="L85">            int amount = scoreDecreaseArray[colorIndex];</span>
//            System.out.println(&quot;Decreasing score by: &quot; + amount);
<span class="fc" id="L87">            app.decreaseScore(amount);</span>
        }
<span class="fc" id="L89">    }</span>

<span class="fc" id="L91">    public boolean getIsLevelEnded() { return isLevelEnded; }</span>

    // Retrieves the list of active balls in the current level
    public List&lt;Ball&gt; getBalls() {
<span class="fc" id="L95">        return balls;</span>
    }

    // Retrieves the list of walls in the current level
    public List&lt;Wall&gt; getWalls() {
<span class="fc" id="L100">        return walls;</span>
    }

    // Retrieves the list of spawners in the current level
    public List&lt;Spawner&gt; getSpawners() {
<span class="fc" id="L105">        return spawners;</span>
    }

    // Retrieves the list of holes in the current level
    public List&lt;Hole&gt; getHoles() {
<span class="fc" id="L110">        return holes;</span>
    }

    // Adds a new ball to the list of active balls in the current level
    public void addBall(Ball ball) {
<span class="fc" id="L115">        balls.add(ball);</span>
<span class="fc" id="L116">    }</span>

    // Removes a ball from the list of active balls in the current level
    public void removeBall(Ball ball) {
<span class="fc" id="L120">        balls.remove(ball);</span>
<span class="fc" id="L121">    }</span>

    /**
     * Loads a level layout from a text file and creates corresponding game entities.
     * 此方法现在不再管理瓷砖，而是在绘制时自动为所有位置（除顶部栏外）添加默认瓷砖。
     *
     * @param layoutFile The path to the layout text file.
     * @param p          The App object used to load the file and create entities.
     */
    public void loadLevel(String layoutFile, App p) {
<span class="fc" id="L131">        String[] lines = p.loadStrings(layoutFile);  // Load the layout file as lines</span>

        // Iterate over each line in the file (row by row)
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (int row = 0; row &lt; lines.length; row++) {</span>
<span class="fc" id="L135">            String line = lines[row];</span>

            // Iterate over each character in the line (column by column)
<span class="fc bfc" id="L138" title="All 2 branches covered.">            for (int col = 0; col &lt; line.length(); col++) {</span>
<span class="fc" id="L139">                char entity = line.charAt(col);</span>

<span class="fc bfc" id="L141" title="All 10 branches covered.">                switch (entity) {</span>
                    case 'X':  // Wall 0
<span class="fc" id="L143">                        walls.add(new Wall(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, 0, p));</span>
<span class="fc" id="L144">                        break;</span>
                    case '1':  // Wall 1
<span class="fc" id="L146">                        walls.add(new Wall(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, 1, p));</span>
<span class="fc" id="L147">                        break;</span>
                    case '2':  // Wall 2
<span class="fc" id="L149">                        walls.add(new Wall(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, 2, p));</span>
<span class="fc" id="L150">                        break;</span>
                    case '3':  // Wall 3
<span class="fc" id="L152">                        walls.add(new Wall(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, 3, p));</span>
<span class="fc" id="L153">                        break;</span>
                    case '4':  // Wall 4
<span class="fc" id="L155">                        walls.add(new Wall(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, 4, p));</span>
<span class="fc" id="L156">                        break;</span>
                    case 'S':  // Spawner
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                        if (col + 2 &lt; line.length()) {</span>
<span class="fc" id="L159">                            int spawnInterval = Character.getNumericValue(line.charAt(col + 1)) * 1000;</span>
<span class="fc" id="L160">                            int ballColor = Character.getNumericValue(line.charAt(col + 2));</span>
<span class="fc" id="L161">                            spawners.add(new Spawner(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, -1, p));</span>
<span class="fc" id="L162">                        }</span>
                        break;
                    case 'H':  // Hole
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">                        if (col + 1 &lt; line.length()) {</span>
<span class="fc" id="L166">                            int holeColor = Character.getNumericValue(line.charAt(col + 1));</span>
<span class="fc bfc" id="L167" title="All 4 branches covered.">                            if (holeColor &gt;= 0 &amp;&amp; holeColor &lt;= 4) {</span>
<span class="fc" id="L168">                                holes.add(new Hole(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, holeColor, p));</span>
<span class="fc" id="L169">                                col++;  // Move to next character (color)</span>
                            }
<span class="fc" id="L171">                        }</span>
                        break;
                    case 'B':  // Ball added to the spawner
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">                        if (col + 1 &lt; line.length()) {</span>
<span class="fc" id="L175">                            int ballColor = Character.getNumericValue(line.charAt(col + 1));</span>
<span class="fc" id="L176">                            Ball ball = new Ball(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, ballColor, 12, p);</span>
<span class="fc" id="L177">                            ball.setIsActive(true);</span>
<span class="fc" id="L178">                            balls.add(ball);</span>
<span class="fc" id="L179">                            col++;  // Skip over the color character</span>
<span class="fc" id="L180">                        }</span>
                        break;
                    case 'A':  // AccelerateTile
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                        if (col + 1 &lt; line.length()) {</span>
<span class="fc" id="L184">                            int direction = Character.getNumericValue(line.charAt(col + 1));</span>
                            String accelDirection;
<span class="pc bpc" id="L186" title="1 of 5 branches missed.">                            switch (direction) {</span>
<span class="fc" id="L187">                                case 0: accelDirection = &quot;up&quot;; break;</span>
<span class="fc" id="L188">                                case 1: accelDirection = &quot;down&quot;; break;</span>
<span class="fc" id="L189">                                case 2: accelDirection = &quot;left&quot;; break;</span>
<span class="fc" id="L190">                                case 3: accelDirection = &quot;right&quot;; break;</span>
<span class="nc" id="L191">                                default: throw new IllegalArgumentException(&quot;Invalid acceleration direction&quot;);</span>
                            }
<span class="fc" id="L193">                            accelerationTiles.add(new AccelerateTile(col * App.CELLSIZE, row * App.CELLSIZE + App.TOPBAR, accelDirection, p));</span>
<span class="fc" id="L194">                            col++;  // Move to next character (direction)</span>
                        }
                        break;
                }
            }
        }
<span class="fc" id="L200">    }</span>

    /**
     * Updates the positions of all balls and checks for collisions with walls and holes.
     *
     * @param p The App object used for the game's main loop.
     */
    public void update(App p) {
        // Iterate through the list of active balls
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (int i = 0; i &lt; balls.size(); i++) {</span>
<span class="fc" id="L210">            Ball ball = balls.get(i);</span>
<span class="fc" id="L211">            ball.updatePosition();  // Update ball's position</span>

            // Check for collisions between the ball and walls
<span class="fc bfc" id="L214" title="All 2 branches covered.">            for (Wall wall : walls) {</span>
<span class="fc" id="L215">                wall.checkCollision(ball, p);</span>
<span class="fc" id="L216">            }</span>

            // Check for attraction between the ball and holes
<span class="fc bfc" id="L219" title="All 2 branches covered.">            for (Hole hole : holes) {</span>
<span class="fc" id="L220">                hole.attractBall(ball, this, p);</span>

                // If the ball is no longer active (captured or deactivated)
<span class="fc bfc" id="L223" title="All 2 branches covered.">                if (!ball.getIsActive()) {</span>
<span class="fc" id="L224">                    balls.remove(i);  // Remove the ball from the list</span>
<span class="fc" id="L225">                    break; // No need to check further holes for this ball</span>
                }
<span class="fc" id="L227">            }</span>

            // Check for collisions with acceleration tiles
<span class="fc bfc" id="L230" title="All 2 branches covered.">            for (AccelerateTile tile : accelerationTiles) {</span>
<span class="fc" id="L231">                tile.checkCollision(ball);  // Accelerates the ball if it's on the tile</span>
<span class="fc" id="L232">            }</span>
        }

        // Check if the level should end (no active balls and no spawners)
<span class="fc bfc" id="L236" title="All 6 branches covered.">        if (balls.isEmpty() &amp;&amp; spawners.isEmpty() &amp;&amp; !isLevelEnded) {</span>
<span class="fc" id="L237">            endLevel(p, &quot;normal&quot;);</span>
        }
<span class="fc" id="L239">    }</span>

    /**
     * Ends the current level and starts the time bonus phase if applicable.
     *
     * @param p The main game application instance.
     */
    public void endLevel(App p, String reason) {
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if (isLevelEnded) {</span>
<span class="fc" id="L248">            return; // 如果关卡已经结束，直接返回，防止重复调用</span>
        }
<span class="fc" id="L250">        isLevelEnded = true;</span>

<span class="fc bfc" id="L252" title="All 3 branches covered.">        switch (reason) {</span>
            case &quot;normal&quot;:
                // Handle normal level ending
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (p.getRemainingTime() &gt; 0) {</span>
<span class="fc" id="L256">                    timeBonusRemaining = p.getRemainingTime(); // Use remaining time for bonus</span>
                }
                break;
            case &quot;timeUp&quot;:
                // Handle level ending due to time up
<span class="fc" id="L261">                timeBonusRemaining = 0; // No bonus if time is up</span>
<span class="fc" id="L262">                break;</span>
            default:
<span class="fc" id="L264">                throw new IllegalArgumentException(&quot;Unknown reason for ending level: &quot; + reason);</span>
        }

        // Initialize positions for yellow tiles animation at the end of the level
<span class="fc" id="L268">        yellowTileTopLeft = new YellowTile(0, App.TOPBAR, -1, p);</span>
<span class="fc" id="L269">        yellowTileBottomRight = new YellowTile(App.WIDTH - App.CELLSIZE, App.HEIGHT - App.CELLSIZE, -1, p);</span>
<span class="fc" id="L270">    }</span>

    /**
     * Draws all entities in the current level, including walls, spawners, holes, and balls.
     * 现在在绘制时自动为所有位置（除顶部栏外）添加默认瓷砖。
     *
     * @param p        The main game application instance used to draw entities.
     */
    public void draw(App p) {
        // 首先绘制默认瓷砖
<span class="fc" id="L280">        drawDefaultTiles(p);</span>

        // 绘制所有墙壁
<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (Wall wall : walls) {</span>
<span class="fc" id="L284">            wall.draw(p);</span>
<span class="fc" id="L285">        }</span>

        // 绘制所有洞
<span class="fc bfc" id="L288" title="All 2 branches covered.">        for (Hole hole : holes) {</span>
<span class="fc" id="L289">            hole.draw(p);</span>
<span class="fc" id="L290">        }</span>

        // 绘制所有生成器
<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (Spawner spawner : spawners) {</span>
<span class="fc" id="L294">            spawner.draw(p);</span>
<span class="fc" id="L295">        }</span>

        // 绘制所有加速板
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (AccelerateTile tile : accelerationTiles) {</span>
<span class="fc" id="L299">            tile.draw(p);</span>
<span class="fc" id="L300">        }</span>

        // 绘制所有活跃的球
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (Ball ball : balls) {</span>
<span class="fc" id="L304">            ball.draw(p);</span>
<span class="fc" id="L305">        }</span>

        // 如果关卡已经结束且游戏未暂停且时间未耗尽，处理剩余时间和黄色瓷砖动画
<span class="pc bpc" id="L308" title="1 of 6 branches missed.">        if (isLevelEnded &amp;&amp; !p.getIsPaused() &amp;&amp; !p.isTimerFinished()) {</span>
<span class="fc" id="L309">            updateTimeBonus(p);</span>
<span class="fc" id="L310">            moveYellowTiles(p);</span>
        }

        // 绘制黄色瓷砖动画
<span class="pc bpc" id="L314" title="1 of 6 branches missed.">        if (isLevelEnded &amp;&amp; !p.getIsPaused() &amp;&amp; !p.isTimerFinished()) {</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">            if (yellowTileTopLeft != null) {</span>
<span class="fc" id="L316">                yellowTileTopLeft.draw(p);</span>
            }
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if (yellowTileBottomRight != null) {</span>
<span class="fc" id="L319">                yellowTileBottomRight.draw(p);</span>
            }
        }
<span class="fc" id="L322">    }</span>

    /**
     * 在关卡绘制时，为所有位置（除顶部栏外）绘制默认的瓷砖。
     *
     * @param p The main game application instance used for drawing.
     */
    void drawDefaultTiles(App p) {
        // 避免每帧重复加载图片，使用已经加载的 defaultTileImage
<span class="fc bfc" id="L331" title="All 2 branches covered.">        for (int row = 0; row &lt; (App.HEIGHT - App.TOPBAR) / App.CELLSIZE; row++) {</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            for (int col = 0; col &lt; App.BOARD_WIDTH; col++) {</span>
<span class="fc" id="L333">                int x = col * App.CELLSIZE;</span>
<span class="fc" id="L334">                int y = row * App.CELLSIZE + App.TOPBAR;</span>
<span class="fc" id="L335">                p.image(defaultTileImage, x, y, App.CELLSIZE, App.CELLSIZE);</span>
            }
        }
<span class="fc" id="L338">    }</span>

    /**
     * Updates the time bonus and converts remaining time into score points.
     *
     * @param p The main game application instance used to update the score.
     */
    void updateTimeBonus(App p) {
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (timeBonusRemaining &gt; 0) {</span>
<span class="fc" id="L347">            long currentTime = p.millis();</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (p.frameCount % 2 == 0) { // Roughly every 2 frames (~0.067 seconds at 30 FPS)</span>
<span class="fc" id="L349">                p.increaseScore(1);</span>
<span class="fc" id="L350">                timeBonusRemaining -= 1;</span>
<span class="fc" id="L351">                p.setRemainingTime(timeBonusRemaining);</span>

                // Ensure timeBonusRemaining does not go negative
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">                if (timeBonusRemaining &lt; 0) {</span>
<span class="nc" id="L355">                    timeBonusRemaining = 0;</span>
                }
//                System.out.println(&quot;时间奖励: 分数增加 1 分，剩余时间奖励分数: &quot; + timeBonusRemaining + &quot; 分&quot;);
            }
<span class="fc" id="L359">        } else {</span>
<span class="fc" id="L360">            isLevelEnded = false;</span>
//            System.out.println(&quot;时间奖励完成，进入下一个关卡。&quot;);
<span class="fc" id="L362">            p.nextLevel(); // Proceed to the next level after time bonus is complete</span>
        }
<span class="fc" id="L364">    }</span>

    /**
     * Animates the movement of yellow tiles in a clockwise direction around the game area.
     *
     * @param p The main game application instance used for animation.
     */
    void moveYellowTiles(App p) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (p.frameCount % 2 == 0) { // Roughly every 2 frames (~0.067 seconds at 30 FPS)</span>
            // Move the top-left yellow tile clockwise
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">            if (yellowTileTopLeft != null) {</span>
<span class="fc" id="L375">                yellowTileTopLeft.update(p);</span>
            }
            // Move the bottom-right yellow tile clockwise
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            if (yellowTileBottomRight != null) {</span>
<span class="fc" id="L379">                yellowTileBottomRight.update(p);</span>
            }
        }
<span class="fc" id="L382">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>