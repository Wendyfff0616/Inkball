<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlayerDrawnLine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">inkball_scaffold</a> &gt; <a href="index.source.html" class="el_package">inkball</a> &gt; <span class="el_source">PlayerDrawnLine.java</span></div><h1>PlayerDrawnLine.java</h1><pre class="source lang-java linenums">package inkball;

import processing.core.PApplet;
import processing.core.PVector;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * The PlayerDrawnLine class represents a line drawn by the player in the Inkball game.
 * It manages the points that define the line, handles drawing the line on the game screen,
 * and checks for collisions with balls.
 */
public class PlayerDrawnLine {
    List&lt;PVector&gt; points;  // Stores the points that make up the line
    static final float LINE_THICKNESS = 10;  // Thickness of the drawn line
    public static final int DELETE_THRESHOLD = 15;  // Threshold for detecting proximity to remove the line
    private int collisionBuffer;  // Buffer to avoid continuous collision detection
    public static final int BUFFER_THRESHOLD = 5;  // Number of frames to wait before checking collisions again

    /**
     * Constructor to initialize a PlayerDrawnLine object.
     */
<span class="fc" id="L25">    public PlayerDrawnLine() {</span>
<span class="fc" id="L26">        points = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L27">    }</span>

    /**
     * Adds a new point to the line.
     *
     * @param x The x-coordinate of the point.
     * @param y The y-coordinate of the point.
     */
    public void addPoint(float x, float y) {
<span class="fc" id="L36">        points.add(new PVector(x, y));</span>
<span class="fc" id="L37">    }</span>

    /**
     * Clears the points in the line, effectively removing it.
     */
    public void clear() {
<span class="fc" id="L43">        points.clear();</span>
<span class="fc" id="L44">    }</span>

    /**
     * Draws the player-drawn line on the screen.
     *
     * @param p The App instance used to draw the line.
     */
    public void draw(App p) {
<span class="fc" id="L52">        p.pushStyle(); // 保存当前绘图状态</span>

<span class="fc bfc" id="L54" title="All 2 branches covered.">        if (points.size() &gt; 1) {</span>
<span class="fc" id="L55">            p.stroke(0);  // Set the line color to black</span>
<span class="fc" id="L56">            p.strokeWeight(LINE_THICKNESS);  // Set the thickness of the line</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">            for (int i = 0; i &lt; points.size() - 1; i++) {</span>
<span class="fc" id="L58">                PVector p1 = points.get(i);</span>
<span class="fc" id="L59">                PVector p2 = points.get(i + 1);</span>
<span class="fc" id="L60">                p.line(p1.x, p1.y, p2.x, p2.y);  // Draw the line between consecutive points</span>
            }
        }

<span class="fc" id="L64">        p.popStyle(); // 恢复绘图状态</span>
<span class="fc" id="L65">    }</span>

    /**
     * Checks for collisions between the ball and the line.
     * If a collision is detected, the ball's velocity is updated, and the line is cleared.
     *
     * @param ball The ball object to check for collision.
     */
    public void checkCollision(Ball ball) {
        // Increment the collision buffer to avoid constant collision checks
<span class="fc" id="L75">        collisionBuffer++;</span>

        // Only check for collisions after the buffer threshold has been reached
<span class="fc bfc" id="L78" title="All 2 branches covered.">        if (collisionBuffer &gt;= BUFFER_THRESHOLD) {</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            for (int i = 0; i &lt; points.size() - 1; i++) {</span>
<span class="fc" id="L80">                PVector p1 = points.get(i);</span>
<span class="fc" id="L81">                PVector p2 = points.get(i + 1);</span>

                // Calculate the future position of the ball based on its current velocity
<span class="fc" id="L84">                PVector ballPosition = new PVector(ball.getX() + ball.getXVelocity(), ball.getY() + ball.getYVelocity());</span>

                // Calculate the distances from the ball to both ends of the line segment
<span class="fc" id="L87">                float distanceToP1 = PVector.dist(p1, ballPosition);</span>
<span class="fc" id="L88">                float distanceToP2 = PVector.dist(p2, ballPosition);</span>
<span class="fc" id="L89">                float lineLength = PVector.dist(p1, p2);</span>

                // Check if the ball is close enough to the line to detect a collision
<span class="fc bfc" id="L92" title="All 2 branches covered.">                if (distanceToP1 + distanceToP2 &lt; lineLength + ball.getRadius()) {</span>
                    // Collision detected, calculate the reflection vector
<span class="fc" id="L94">                    PVector lineVector = PVector.sub(p2, p1);</span>
<span class="fc" id="L95">                    PVector normal1 = new PVector(-lineVector.y, lineVector.x);  // Perpendicular normal vector 1</span>
<span class="fc" id="L96">                    PVector normal2 = new PVector(lineVector.y, -lineVector.x);  // Perpendicular normal vector 2</span>

                    // Normalize the normal vectors
<span class="fc" id="L99">                    normal1.normalize();</span>
<span class="fc" id="L100">                    normal2.normalize();</span>

                    // Choose the normal vector that is closer to the ball
<span class="fc" id="L103">                    PVector midpoint = PVector.add(p1, p2).div(2);</span>
<span class="fc" id="L104">                    PVector normal = PVector.dist(midpoint.copy().add(normal1), ballPosition) &lt;</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                            PVector.dist(midpoint.copy().add(normal2), ballPosition) ? normal1 : normal2;</span>

                    // Calculate the new velocity using the reflection formula
<span class="fc" id="L108">                    PVector velocity = new PVector(ball.getXVelocity(), ball.getYVelocity());</span>
<span class="fc" id="L109">                    float dotProduct = velocity.dot(normal);</span>
<span class="fc" id="L110">                    PVector newVelocity = PVector.sub(velocity, PVector.mult(normal, 2 * dotProduct));</span>

                    // Update the ball's velocity
<span class="fc" id="L113">                    ball.setXVelocity(newVelocity.x);</span>
<span class="fc" id="L114">                    ball.setYVelocity(newVelocity.y);</span>

                    // Clear the line after the collision
<span class="fc" id="L117">                    clear();</span>

                    // Reset the collision buffer after detecting a collision
<span class="fc" id="L120">                    collisionBuffer = 0;</span>
<span class="fc" id="L121">                    break;</span>
                }
            }
        }
<span class="fc" id="L125">    }</span>

    /**
     * Checks if any part of the line is near a given point, used for detecting line deletion.
     *
     * @param x The x-coordinate of the point to check.
     * @param y The y-coordinate of the point to check.
     * @return True if the line is near the point, otherwise false.
     */
    public boolean isNear(float x, float y) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        for (int i = 0; i &lt; points.size() - 1; i++) {</span>
<span class="fc" id="L136">            PVector p1 = points.get(i);</span>
<span class="fc" id="L137">            PVector p2 = points.get(i + 1);</span>

            // Calculate the shortest distance from the point to the line segment
<span class="fc" id="L140">            float distanceToLine = distToSegment(new PVector(x, y), p1, p2);</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (distanceToLine &lt; DELETE_THRESHOLD) {</span>
<span class="fc" id="L142">                return true;  // Return true if the point is close enough to the line</span>
            }
        }
<span class="fc" id="L145">        return false;</span>
    }

    /**
     * Helper method to calculate the shortest distance from a point to a line segment.
     *
     * @param point The point to check.
     * @param v     One endpoint of the line segment.
     * @param w     The other endpoint of the line segment.
     * @return The shortest distance from the point to the line segment.
     */
    private float distToSegment(PVector point, PVector v, PVector w) {
<span class="fc" id="L157">        float l2 = PVector.dist(v, w) * PVector.dist(v, w);  // Length of the segment squared</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (l2 == 0.0) return PVector.dist(point, v);  // If v == w, return distance to point v</span>
<span class="fc" id="L159">        float t = PVector.dot(PVector.sub(point, v), PVector.sub(w, v)) / l2;</span>
<span class="fc" id="L160">        t = Math.max(0, Math.min(1, t));  // Clamp t to the range [0,1]</span>
<span class="fc" id="L161">        PVector projection = PVector.add(v, PVector.mult(PVector.sub(w, v), t));  // Projection of the point on the line</span>
<span class="fc" id="L162">        return PVector.dist(point, projection);  // Distance from the point to the line segment</span>
    }

    public List&lt;PVector&gt; getPoints() {
<span class="fc" id="L166">        return points;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>